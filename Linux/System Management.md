#### Commands
- `runlevel` - (8) Print previous and current SysV runlevel
- `crontab`
  - (5) tables for driving cron
  - (1) maintain crontab files for individual users (Vixie Cron)
- `uptime` - (1) Tell how long the system has been running.
- `uname`
  - (1) print system information
  - (2) get name and information about current kernel
- `init` - (1) systemd system and service manager
- `visudo` - (8) edit the sudoers file
- `time`
  - (1) run programs and summarize system resource usage
  - (7) overview of time and timers
  - (3am) time functions for gawk
  - (2) get time in seconds
* `shutdown` \[option\] time \[message\]
	A very traditional command used to shutdown or restart the system is unsurprisingly called shutdown. The shutdown command adds extra functions to the power off process: it automatically notifies all logged-in users with a warning message in their shell sessions and new logins are prevented. Command shutdown acts as an intermediary to SysV or systemd procedures, that is, it executes the requested action by calling the corresponding action in the services manager adopted by the system. ^shutdown
	* The systemctl command can also be used to turn off or to restart the machine in systems employing systemd. To restart the system, the command `systemctl reboot` should be used. To turn off the system, the command `systemctl poweroff` should be used. Both commands require root privileges to run, as ordinary users can not perform such procedures.
	* Some Linux distributions will link poweroff and reboot to systemctl as individual commands.
		`/usr/sbin/poweroff -> /bin/systemctl`

### Time Management
#### System Time
* When a Linux computer boots up, it starts keeping time. We refer to this as a system clock, since it is updated by the operating system. In addition, modern computers will also have a hardware or real time clock. This hardware clock is often a feature of the motherboard and keeps time regardless if the computer is running or not. During boot, the system time is set from the hardware clock, but for the most part these two clocks run independently of each other.
* system clock is set to UTC time. Local time can be generated by adding an offset and a daylight savings to UTC time.
* `date` prints local time
	* `-u` UTC
	* `[-I[FMT]/--iso8601=FMT]` FMT=date
	* `-R` RFC 5322 
	* `--rfc-3339`
	* custom format `date [format]`
		* `%a` Sun
		* `%A` Sunday
		* `%b` Jan
		* `%B` January
		* `%c` Thu Mar  3 23:05:25 2005
		* `%d` day of month number
		* `%D` %m/%d/%y
		* `%H` hour
		* `%I` hour 0-12
		* `%j` day of year
		* `%m` month number
		* `%M` minute
		* `%p` AM/PM
		* `%S` second
		* `%u` day of week number, monday=1 (1-7)
		* `%w` day of week number, sunday=0 (0-6)
		* `%U` week number of year
		* `%y` last 2 digits of year
		* `%Y` year
	* `--date=[date[time]]` can customize input day which by default is now
	* `--debug` will print how it's being parsed
* Hardware clock: `hwclock`
* `timedatectl` is used to check general status of time and date, including if network time has been synced.
	* if NTP is unavailable, it's best to set time using this.
		* `timedatectl set-time '2011-11-25 14:00:00'`
		* `timedatectl set-time '14:00:00'`
	* on systemd based distros, it is preferred to set local timezone by this
		* `timedatectl list-timezones`
		* `timedatectl set-timezone Asia/Tehran`
	* if it's necessary to disable NTP, you can use systemctl, or timedatectl.
		* `timedatectl set-ntp no`
	* setting timezone without timedatectl (good for new machines)
		* `/usr/share/zoneinfo` contains categorized timezones
		* `/etc/localtime` will be read when linux needs to determine local tz
			* `ln -s /usr/share/zoneinfo/Asia/Tehran /etc/localtime`
			* `hwclock --systohc` I didn't get this! read page 253

#### Network Time Protocol (NTP)
* The most accurate time is measured by reference clocks, which are typically atomic clocks. The modern world has devised a system where all internet-connected computer systems can be synchronised to these reference clocks using what is known as the Network Time Protocol (NTP)
* important terms
	* **Offset**: refers to the absolute difference between system time and NTP time.
	* **Step**: if the time offset between the NTP provider and a consumer is greater than 128ms, then NTP will perform a single significant change to system time.
	* **Slew**: slewing refers to the changes made to system time when the offset between system time and NTP is less than 128ms. If this is the case, then changes will be made gradually.
	* **Insane Time**: if the offset between system time and NTP time is greater than 17 minutes, then the system time is considered insane and the NTP daemon will not introduce any changes to system time. Special steps will have to be taken to bring system time within 17 minutes of proper time.
	* **Drift**: refers to the phenomenon where two clocks become out of sync over time.
	* **Jitter**: refers to the amount of drift since the last time a clock was queried. So if the last NTP sync occurred 17 minutes ago, and the offset between the NTP provider and consumer is 3 milliseconds, then 3 milliseconds is the jitter.
* way of implementation
	* if `timedatectl` is used by distro, then an SNTP is implemented by default rather than a full NTP implementation. This is a less complex implementation and means that your machine will not be able to serve NTP other machines.
		* In this case, SNTP won't work unless timesyncd is running.
			* `systemctl status systemd-timesyncd`
		* verify SNTP sync status: `timedatectl show-timesync --all`
	* NTP Daemon
		* `ntpd` is daemon that runs in the background and compares the system time to network time. It allows the machine to be a time consumer and a time provider.
			* `systemctl status ntpd`
			* NTP queries happen on TCP port 123. if NTP fails, ensure that this port is open and listening.
		* NTP configs
			* `/etc/ntp.conf`
				* ntp server syntax `server [ip/url]`
		* `ntpdate`
			* If desync is more than 17 minutes:
				* `systemctl stop ntpd`
				* `ntpdate [ip/url of an ntp server]` to perform a one time sync
		* `ntpq` monitors status of NTP
			* `-p` will print
				* `remote`: hostname of NTP provider
				* `refid`: reference ID of the NTP provider
				* `st`: stratum of the provider
				* `when`: number of seconds since the last query
				* `poll`: number of seconds between queries
				* `reach`: status ID to indicate whether a server was reached. successful connections will increase this by 1.
				* `delay`: time in ms between query and response by the server.
				* `offset`: time in ms between sys time and NTP time
				* `jitter`: offset in ms between sys time and NTP in the last query
			* omit options to enter interactive mode
	* Chrony: page 269

### Logging
#### Traditional Logging Services
* `syslog`
* `syslog-ng ("syslog new generation")`
* `rsyslog ("the rocket-fast system for log processing")`
	* client-server model, and each of the client and the server can live in a single machine, or on different machines.
	* rsyslog's daemon, `rsyslogd` works with `klogd` which manages kernel messages.
* logs are found in `/var/log` because they are variable data. they can be classified into `system logs`, `user logs`, or `program logs`.
* service log examples
	* `/var/log/cups/` directory for logs of the Common Unix Printing System. It commonly includes the following default log files: `error_log`, `page_log` and `access_log`.
	* `/var/log/apache2/ or /var/log/httpd/` directory for logs of the Apache Web Server. It commonly includes the following default log files: `access.log`, `error_log`, and `other_vhosts_access.log`.
	* `/var/log/mysql/` directory for logs of the MySQL Relational Database Management System. It commonly includes the following default log files: `error_log`, `mysql.log` and `mysql-slow.log`.
	* `/var/log/samba/` directory for logs of the Session Message Block (SMB) protocol. It commonly includes the following default log files: `log.`, `log.nmbd` and `log.smbd`.
	* The exact name and contents of log files may vary across Linux distributions. There are also logs particular to specific distributions such as /var/log/dpkg.log (containing information related to dpkg packages) in Debian GNU/Linux and its derivatives.
* system log examples
	* `/var/log/auth.log`: logged users, sudo information, cron jobs, failed login attempts, etc
	* `/var/log/syslog` is a centralized file for practically all of the logs captured by rsyslogd. Because it includes so much information, logs are distributed across other files according to the configuration supplied in `/etc/rsyslog.conf`.
	* `/var/log/debug` debug info from programs
	* `/var/log/kern.log` kernel messages
	* `/var/log/messages` informative messages which are not related to the kernel but to other services. It is also the default remote client log destination in a centralized log server implementation.
	* `/var/log/daemon.log` info related to backgrounds daemons and services
	* `/var/log/mail.log` info related to email server
	* `/var/log/Xorg.0.log` info related to the graphic card
	* `/var/log/utmp and /var/log/wtmp` successful logins
	* `/var/log/btmp` failed login attempts; e.g. brute force attacks via ssh
	* `/var/log/faillog` failed authentication attempts
	* `/var/log/lastlog` date and time of recent user logins
* reading logs
	* `less` and `more`
	* `zless` and `zmore` are like less and more but for `gzip` files
	* `tail`
		* `-[n]` sets number of lines=10
		* `-f` will dynamically append new added lines
	* `grep`
	* Note that there are graphical tools for reading logs, like `gnome-logs` or `KSystemLog`.
	* binary logs
		* `/var/log/wtmp`
			* `who`: shows who is logged on
			* `w`: shows who is logged on and what they are doing
			* `last`: show a listing of last logged users, by default goes through this log file
			* `utmpdump /var/log/wtmp`: dump UTMP and WTMP files in raw format
		* `/var/log/btmp`
			* `utmpdump /var/log/btmp`: dump UTMP and WTMP files in raw format
			* `last -f` or `lastb`: shows a listing of last logged users, lastb by default goes through this file
		* `/var/log/faillog`
			* `faillog -a | less`
		* `/var/log/lastlog`
			* `lastlog | less`
	* output format
		* timestamp
		* hostname from which the message was generated
		* name of program/service that generated the message
		* the PID of the program that generated the message
		* description of the action that took place
* how messages are turned into logs
	1. applications, services and the kernel write messagess in special files (sockets and memory), e.g. `/dev/log`, or `/dev/kmsg`.
	2. rsyslogd gets info from them
	3. depending on the rules found in rsyslogd configs, it'll move them to the corresponding file.
* `systemctl list-sockets --all`
* Facilities, Priorities, and Actions
	* rsyslog config file `/etc/rsyslog.conf`. It's normally divided into 3 sections.
	* `MODULES` section include module support for logging, message capability, and UDP/TCP log reception
	* `GLOBAL DIRECTIVES` section allows us to configure a number of things such as logs and log directory permissions.
	* `RULES` section
		* is where facilities, priorities, and actions come in. The settings in this section tell the logging daemon to filter messages according to their certain rules and log them or send them where required.
		* Each log message is given a facility number and keyword that are associated with the Linux internal subsystem that produced the message. Look for a table called `rsyslog-facility-table`. Furthermore, each message is assigned a priority level. Loof for a table called `rsyslog-priority-table`.
		* sytax is `[facility(s)].[priority] [action]`
			* The `[facility(s)].[priority]` **selector** filters messages to match.
				* semicolon `;` can be used to use multiple selectors.
				* `*.*` means all messages irrespective of their priority, from all facilities should be redirected to the action.
			* **Facilities** can be a comma-seperated `,` list. Facility value can be `*` which designates all facilities.
				* If `*` is used for facility, exclusion of some facilities can be done like this.
					* `*.[p];[excluded facility(s)].none [logfile]` means that messages from `[excluded facility(s)]` will be discarded from going to `[logfile]`.
			* **Priority** levels are hierarchically inclusive, which means rsyslog will match that level and higher. Priority can be `*` which designates all priorities.
				* An equal sign `=` can be used to designate a non-inclusive exact priority. e.g. `*.=debug` selector will only match Debug messages.
			* **Actions** tell rsyslog where should the message be redirected to.
				* a minus `-` before action is for prevention of excessive disk writes. e.g. `*.* -/var/log/.log`
* `logger` is a handy tool for shell scripting
	* it will append any messages it receives to `/var/log/syslog` or `/var/log/messages` when logging to a remote central log server.
		* `logger this comment goes into "/var/log/syslog"`
* rsyslog as central log server
	* Templates and Filter conditions
		* for more info refer to page 297 or `man rsyslog.conf`
			```text
			$template RemoteLogs,"/var/log/remotehosts/%HOSTNAME%/%$NOW%.%syslogseverity-text%.log"
			if $FROMHOST-IP=='192.168.1.4' then ?RemoteLogs
			& stop
			```
* Log Rotation
	* purpose
		1. prevent older log files from using more disk space than necessary
		2. keep logs to a manageable length for ease of consultation
	* utility `logrotate`
		* jobs
			* moving to new names
			* archiving/compressing
			* emailing to sysadmin
			* deleting
		* `/etc/logrotate.conf` for global conf
		* `/etc/logrotate.d/` for specific conf e.g. `/etc/logrotate.d/rsyslog`
			```text
			/var/log/syslog
			/var/log/mail.info
			/var/log/mail.warn
			/var/log/mail.err
			/var/log/mail.log
			/var/log/daemon.log
			/var/log/kern.log
			/var/log/auth.log
			/var/log/user.log
			/var/log/lpr.log
			/var/log/cron.log
			/var/log/debug
			/var/log/messages
			{
					rotate 4
					weekly
					missingok
					notifempty
					compress
					delaycompress
					sharedscripts
					postrotate
							/usr/lib/rsyslog/rsyslog-rotate
					endscript
			}
			```
		* options `man logrotate.conf`
* Kernel Ring Buffer: is a mechanism to store kernel messages before rsyslog boots up. `dmesg`

> rsyslog-facility-table

| number | keyword | description |
| :---- | :-----: | :----- |
| 0 | kern | Linux kernel messages |
| 1 | user | User-level messages |
| 2 | mail | Mail system |
| 3 | daemon | System daemons |
| 4 | auth,authpriv | Security/Authorization messages |
| 5 | syslog | syslogd messages |
| 6 | lpr | Line printer subsystem |
| 7 | news | Network news subsystem |
| 8 | uucp | UUCP (Unix-to-Unix Copy Protocol) subsystem |
| 9 | cron | Clock daemon |
| 10 | auth,authpriv| Security/Authorization messages |
| 11 | ftp | FTP (File Transfer Protocol) messages |
| 12 | ntp | NTP (Network Time Protocol) daemon |
| 13 | security | Log audit |
| 14 | console | Log alert |
| 15 | cron | Clock daemon |
| 16 | local0 through local 17 | Local use 0 - 7 |

> rsyslog-priority-table

| code | severity | keyword | description |
| :---- | :----: | :----: | :----- |
| 0 | Emergency | emerg, panic | System is unusable |
| 1 | Alert | alert | Action must be taken immediately |
| 2 | Critical | crit | Critical conditions |
| 3 | Error | err, error | Error conditions |
| 4 | Warning | warn, warning | Warning conditions |
| 5 | Notice | notice | Normal but significant condition |
| 6 | Informational | info | Informational messages |
| 7 | Debug | debug | Debug-level messages |

#### Journald
* general adoption of systemd has standardized `systemd-journald`
* It's the system service which takes care of receiving logging information from a variety of sources. Its mission is that of creating and maintaining a structured and indexed journal.
* `/etc/systemd/journald.conf` global conf
* `/etc/systemd/journal.conf.d/*.conf` specific conf
* conf `man journald.conf`
* It's not stored in plain text file, but binary. It's either in a persistent mode on disk or in a volatile mode on RAM. Therefore interaction with it should be done with `journalctl`.
* `journalctl`
	* `-r` messages printed in reverse order
	* `-f` like tail -f
	* `-e` it will jump to the end of the journal so that the latest entries are visible within the pager
	* `-n [n]/--lines=[n]` print n most recent lines
	* `-k/--dmesg` equals to using dmesg
* navigate output
	* `pgup, pgdown`
	* arrow keys
	* `>` to go to the end of the output
	* `<` to go to the begninning of the output
	* `/` searches forward, `?` searches backwards
	* `n, shift+n` goes to next/previous search match
* filter data
	* boot number: `--list-boots`, `-b/--boot`
		* I think boot refers to system session? #todo page: 317
	* priority: `-p [priority]`
	* Time Interval
		* `--since [datetime]`
		* `--until [datetime]`
		* `[datetime]`: `YYYY-MM-DD HH:MM:SS`
			* if date is omitted, current day is assumed.
			* if time is omitted, midnight is assumed.
		* `[datetime]`: relative
			* `integer time-unit ago`
				* `2 minutes ago`
			* `[+-]integer time-unit`
				* `-2 minutes`
		* `[datetime]`: keywords
			* yesterday
			* today
			* tomorrow
			* now
		* `man systemd.time`
	* program `journalctl /path/to/executable`
	* unit: `-u [unit]`
	* fields
		* syntaxes
			* `<field-name>=<value>`
			* `_<field-name>=<value>_`
			* `__<field-name>=<value>`
		* `PRIORITY=` syslog priority decimal value
		* `SYSLOG_FACILITY=` syslog facility decimal value
		* `_PID=` filter by process ID
		* `_BOOT_ID=`
		* `_TRANSPORT=`
			* `audit` kernel audit subsystem
			* `driver` generated internally
			* `syslog` syslog socket
			* `journal` native journal protocol
			* `stdout` services standard output or standard error
			* `kernel` kernel ring buffer (dmesg)
		* you can combine fields. by default they will be `AND`-ed together. If you want to `OR` them, you should use `+` between fields.
			* `journalctl PRIORITY=3 + SYSLOG_FACILITY=0`
		* `man systemd.journal-fields 7`
		* Journal fields fall in any of the following categories: `“User Journal Fields”`, `“Trusted Journal Fields”`, `“Kernel Journal Fields”`, `“Fields on behalf of a different program”` and `“Address Fields”`
* manual entry
	* `systemd-cat`: works like `logger`, but for journalctl
	* note that `systemd-cat` can take `stdin`, `stdout`, and `stderr` as input.
	* `systemd-cat`: this way it will take whatever input you type before `ctrl+c`
	* `[command+args] | systemd-cat`
	* `systemd-cat [command+args]`: the output of command will be used
	* `systemd-cat -p [priority]`: which can be combined with different ways of feeding it input
	* `man systemd-cat`
* persistent storage
	* options as location of the journal:
		* turned off
		* volatile and in memory: deleted in every reboot and stored in `/run/log/journal`
		* persistent and in disk: `/var/log/journal`
	* default behavior: if `/var/log/journal` does NOT exist, logs will be saved in a volatile way to a dir in `/run/log/journal` with a file name that is stored in `/etc/machine-id`. And if `/var/log/journal` exists, logs will be stored there.
	* `journal.conf`
		* `Storage=`
			* `volatile` stored exclusively in memory
			* `persistent` exclusively in disk except for the early stages of booting
			* `auto` this is the default
			* `none` 
* delete old files
	* `SystemMaxUse=`, `RuntimeMaxUse=`
	* `SystemKeepFree=`, `RuntimeKeepFree=`
	* `SystemMaxFilesize=`, `RuntimeMaxFilesize=`
	* `SystemMaxFiles=`, `RuntimeMaxFiles=`
	* `MaxRetentionSec=`, `MaxFileSec=`
	* `man journald.conf`, also page 327
	* manually vacuuming
		* `--vacuum-time`
		* `--vacuum-size`
		* `--vacuum-files`
		* `--flush` (SIGUSR1)
		* `--sync` (SIGRTMIN+1)
* retreive files from a rescue system: `-D [file]/--directory=[file]`
	* `-m/--merge`
	* `--file`
	* `--root`

### OpenSSH
* Securing data with encryption is of paramount importance in many aspects of today’s system administration — even more so when it comes to accessing systems remotely. As opposed to insecure solutions such as telnet, rlogin or FTP, the SSH (Secure Shell) protocol was designed with security in mind. Using public key cryptography, it authenticates both hosts and users and encrypts all subsequent information exchange. Furthermore, SSH can be used to establish port tunnels, which — amongst other things — allows for a non-encrypted protocol to transmit data over an encrypted SSH connection. The current, recommended version of the SSH protocol is 2.0. OpenSSH is a free and open source implementation of the SSH protocol.
* basic OpenSSH client config and usage
	* `ssh [user]@[host]`
		* after this, you will prompted password after which this warning is shown.
		* `Warning: Permanently added '192.168.1.77' (ECDSA) to the list of known hosts.`
		* The messages are quite self-explanatory: as it was the first time that you established a connection to the 192.168.1.77 remote server, its authenticity could not be checked against any database. Thus, the remote server provided an ECDSA key fingerprint of its public key (using the SHA256 hash function). Once you accepted the connection, the public key of the remote server was added to the known hosts database, thus enabling the authentication of the server for future connections.
		* This list of known hosts' public keys is kept in the file known_hosts which lives in ~/.ssh
		* Both .ssh and known_hosts were created after the first remote connection was established. ~/.ssh is the default directory for user-specific configuration and authentication information.
	* `ssh [user]@[host] [command]`
	* Now suppose you establish a new remote connection with a host that happens to have the same IP address as halof (a common thing if you use DHCP in your LAN). You will be warned about the possibility of a man-in-the-middle attack:
		```text
		carol@debian:~$ ssh john@192.168.1.77
		@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		@
		WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!
		@
		@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
		Someone could be eavesdropping on you right now (man-in-the-middle attack)!
		It is also possible that a host key has just been changed.
		The fingerprint for the ECDSA key sent by the remote host is
		SHA256:KH4q3vP6C7e0SEjyG8Wlz9fVlf+jmWJ5139RBxBh3TY.
		Please contact your system administrator.
		Add correct host key in /home/carol/.ssh/known_hosts to get rid of this message.
		Offending ECDSA key in /home/carol/.ssh/known_hosts:1
		remove with:
		ssh-keygen -f "/home/carol/.ssh/known_hosts" -R "192.168.1.77"
		ECDSA host key for 192.168.1.77 has changed and you have requested strict checking.
		Host key verification failed.
		```
		* Since you are not dealing with a man-in-the-middle attack, you can safely add the public key fingerprint of the new host to .ssh/known_hosts. As the message indicates, you can first use the command `ssh-keygen -f "/home/carol/.ssh/known_hosts" -R "192.168.1.77"` to remove the offending key (alternatively, you can go for `ssh-keygen -R 192.168.1.77` to delete all keys belonging to 192.168.1.77 from `~/.ssh/known_hosts`). Then, you will be able to establish a connection to the new host.
	* Key-based Logins
		* You can set up your SSH client to not provide any passwords at login but use public keys instead. This is the preferred method of connecting to a remote server via SSH, as it is far more secure. The first thing you have to do is create a key pair on the client machine. To do this, you will use ssh-keygen with the -t option specifying the type of encryption you want (Elliptic Curve Digital Signature Algorithm in our case). Then, you will be asked for the path to save the key pair (`~/.ssh/` is convenient as well as the default location) and a passphrase. While a passphrase is optional, it is highly recommended to always use one. `ssh-keygen -t ecdsa`
		* When creating the key pair, you can pass ssh-keygen the `-b` option to specify the key size in bits (e.g.: `ssh-keygen -t ecdsa -b 521`).
		* The previous command produced two more files in your ~/.ssh directory:
			* `id_ecdsa` private key
			* `id_ecdsa.pub` public key
			* In asymmetric cryptography (aka public-key cryptography), the public and private keys are mathematically related to one another in such a way that whatever is encrypted by one can only be decrypted by the other.
		* The next thing you need to do is add your public key to the `~/.ssh/authorized_keys` file of the user you want to log in as on the remote host (if the `~/.ssh` directory does not already exist, you will have to create it first). You can copy your public key into the remote server in a number of ways: using a USB flash drive, through the `scp` command — which will transfer the file over using SSH — or by catting out the content of your public key and piping it into ssh like so: `cat id_ecdsa.pub |ssh ina@192.168.1.77 'cat >> .ssh/authorized_keys'`
		* Once your public key has been added to the authorized_keys file on the remote host, you can face two scenarios when trying to establish a new connection:
			* If you did not provide a passphrase when creating the key pair, you will be logged in automatically. Although convenient, this method can be insecure depending on the situation
			* If you provided a passphrase when creating the key pair, you will have to enter it on every connection much in the same way as if it was a password. Apart from the public key, this method adds an extra layer of security in the form of a passphrase and can — therefore — be considered more secure. As far as convenience goes — however — it is is exactly the same as having to enter a password every time you establish a connection. If you don’t use a passphrase and someone manages to obtain your private SSH key file, they would have access to every server on which your public key is installed.
			* 
		* There is a way which combines security and convenience, though: using the SSH authentication agent (ssh-agent). The authentication agent needs to spawn its own shell and will hold your private keys — for public key authentication — in memory for the remainder of the session. Let us see how it works in a little bit more detail:
			* Use ssh-agent to start a new Bash shell: `ssh-agent /bin/bash`
			* Use the ssh-add command to add your private key to a secure area of memory. If you supplied a passphrase when generating the key pair — which is recommended for extra security — you will be asked for it: `ssh-add`
				* Once your identity has been added, you can login to any remote server on which your public key is present without having to type your passphrase again. It is common practice on modern desktops to perform this command upon booting your computer, as it will remain in memory until the computer is shutdown (or the key is unloaded manually).
		* public-key algorithms
			* RSA
				Named after its creators Ron Rivest, Adi Shamir and Leonard Adleman, it was published in 1977. It is considered secure and still widely used today. Its minimum key size is 1024 bits (default is 2048).
			* DSA
				The Digital Signature Algorithm has proven to be insecure and it was deprecated as of OpenSSH 7.0. DSA keys must be exaclty 1024 bits in length.
			* ecdsa
				The Elliptic Curve Digital Signature Algorithm is an improvement on DSA and — therefore — considered more secure. It uses elliptic curve cryptography. ECDSA key length is determined by one of the three possible elliptic curve sizes in bits: 256, 384 or 521.
			* ed25519
				It is an implementation of EdDSA — Edwards-curve Digital Signature Algorithm — that uses the stronger 25519 curve. It is considered the most secure of all. All Ed25519 keys have a fixed length of 256 bits.
			* If invoked with no -t specification, ssh-keygen will generate an RSA key pair by default.
* The Role of OpenSSH **Server** host keys
	* The global configuration directory for OpenSSH lives in the `/etc` directory.
	* Apart from `moduli` and the configuration files for the client `(ssh_config)` and the server `(sshd_config)`, you will find four key pairs — a key pair for each supported algorithm — that are created when the OpenSSH server is installed. As already noted, the server uses these host keys to identify itself to clients as required. Their name pattern is as follows: 
		* Private Key: `ssh_host_prefix + algorithm + key suffix` `(ssh_host_rsa_key)`
		* Public Key: `ssh_host_ prefix + algorithm + key.pub suffix` `(ssh_host_rsa_key.pub)`
	* A fingerprint is created by applying a cryptographic hash function to a public key. As fingerprints are shorter than the keys they refer to, they come in handy to simplify certain key management tasks.
	* The permissions on the files containing the private keys are `0600` or `-rw-------`: only readable and writable by the owner (root). On the other hand, all public key files are also readable by members in the owner group and everybody else (`0644` or `-rw-r—r--`)
	* You can view the fingerprints of the keys by passing `ssh-keygen` the `-l` switch. You must also provide the `-f` to specify the key file path.
		* To view the key fingerprint as well as its random art, just add the `-v` switch.
* SSH Port Tunnels
	* OpenSSH features a very powerful forwarding facility whereby traffic on a source port is tunnelled — and encrypted — through an SSH process which then redirects it to a port on a destination host. This mechanism is known as port tunnelling or port forwarding and has important advantages like the following:
		* It allows you to bypass firewalls to access ports on remote hosts.
		* It allows access from the outside to a host on your private network.
		* It provides encryption for all data exchange.
	* Local Port Tunnel
		* You define a port locally to forward traffic to the destination host through the SSH process which sits in between. The SSH process can run on the local host or on a remote server. For instance, if for some reason you wanted to tunnel a connection to www.gnu.org through SSH using port 8585 on your local machine, you would do something like this:
		* `ssh -L 8585:www.gnu.org:80 debian`
		* The explanation is as follows: with the -L switch, we specify the local port 8585 to connect to http port 80 on www.gnu.org using the SSH process running on debian — our localhost. We could have written `ssh -L 8585:www.gnu.org:80 localhost` with the same effect. If you now use a web browser to go to http://localhost:8585, you will be forwarded to www.gnu.org.
		* If you wanted to do the exact same thing but connecting through an SSH process running on halof, you would have proceeded like so
		* `ssh -L 8585:www.gnu.org:80 -Nf ina@192.168.1.77`
		* It is important that you note three details in the command:
			* Thanks to the -N option we did not login to halof but did the port forwarding instead.
			* The -f option told SSH to run in the background.
			* We specified user ina to do the forwarding: ina@192.168.1.77
	* Remote Port Tunnel
		* In remote port tunnelling (or reverse port forwarding) the traffic coming on a port on the remote server is forwarded to the SSH process running on your local host, and from there to the specified port on the destination server (which may also be your local machine).
		* For example, say you wanted to let someone from outside your network access the Apache web server running on your local host through port 8585 of the SSH server running on halof (192.168.1.77). You would proceed with the following command:
		* `ssh -R 8585:localhost:80 -Nf ina@192.168.1.77`
		* Now anyone who establishes a connection to halof on port 8585 will see Debian's Apache2 default homepage.
		* There is a third, more complex type of port forwarding which is outside the scope of this lesson: *dynamic port forwarding*. Instead of interacting with a single port, this type of forwarding uses various TCP communications across a range of ports.

### Starting a System
#### Linux Boot Process
* Boot process Steps
	1. The workstation firmware starts, performing a quick check of the hardware, called a *Power-On Self Test (POST)*, and then it looks for a bootloader program to run from a bootable device.
	2. The bootloader runs and determines what Linux kernel program to load.
	3. The kernel program loads into memory and starts the necessary background programs required for the system to operate (such as a graphical desktop manager for desktops or web and database servers for servers).
* Usually the boot messages scroll by somewhat quickly, and it’s hard to see just what’s happening. If you need to troubleshoot boot problems, you can review the boot-time messages using the `dmesg` command ([[Linux/System Management#^dmesg]]).

#### Firmware Startup
* All IBM-compatible workstations and servers utilize some type of built-in firmware to control how the installed operating system starts. On older workstations and servers, this firmware was called the *Basic Input/Output System (BIOS)*. On newer workstations and servers, a new method, called the *Unified Extensible Firmware Interface (UEFI)*, is responsible for maintaining the system hardware status and launching an installed operating system.
* UEFI
	* Intel created the *Extensible Firmware Interface (EFI)* in 1998 to address some of the limitations of BIOS. The adoption of EFI was somewhat of a slow process, but by 2005 the idea caught on with other vendors, and the *Universal EFI* (UEFI) specification was adopted as a standard. These days, just about all IBM-compatible desktop and server systems utilize the UEFI firmware standard.
	* Instead of relying on a single boot sector on a hard drive to hold the bootloader program, UEFI specifies a special disk partition, called the EFI System Partition (ESP) to store bootloader programs. This allows for any size of bootloader program, plus the ability to store multiple bootloader programs for multiple operating systems.
	* On Linux systems, the ESP is typically mounted in the `/boot/efi` folder, and the bootloader files are typically stored using the `.efi` filename extension.
	* The `efibootmgr` Linux application allows you to create and remove boot entries or change the boot order.

#### Process Initialization: init
* A Linux system comprises many programs running in background to provide services for the system. The init program starts all of those programs when the Linux system starts up. This is called the *initialization process*.
* When the kernel finishes loading, it looks for the init program in one of three locations:
	* `/sbin/init`
	* `/etc/init`
	* `/bin/init`
	* If none of these files exist, the kernel attempts to start a generic shell session using the `/bin/sh` program. If that fails as well, the kernel enters panic mode and stops processing.
* The main job of the init program is to start other programs. The programs that start are based on the features that you want running in your Linux system.
* Besides `systemctl`, there’s also a `systemd-delta` command that allows you to identify when multiple configuration files exist and overwrite each other.
